<html lang="en">
<head>
<meta charset="UTF-8"> 
<link rel="stylesheet" href="lib/angular-material/angular-material.css">
<script src="lib/angular/angular.js"></script>
<script src="lib/angular-animate/angular-animate.js"></script>
<script src="lib/angular-aria/angular-aria.js"></script>
<script src="lib/angular-messages/angular-messages.js"></script>
<script src="lib/angular-material/angular-material.js"></script>
<script src="lib/qcode-decoder/build/qcode-decoder.min.js"></script>
<script src="lib/qr-js/qr.js"></script>
<style>
canvas {
	height: 35vh;
	width: 30vw;
	border: 1px solid black;
}
</style>
<script>
'use strict';

// The following code is written as if var is let in order to allow for easy es6 conversion

angular.module('WMJS', ['ngMaterial'])
.controller('WMJSCtrl', [
	'$timeout',
	function ($timeout) {
		var self = this;
		
		self.original = document.getElementById('wm-original');
		self.watermark = document.getElementById('wm-watermark');
		self.processed = document.getElementById('wm-processed');
		self.analyzed = document.getElementById('wm-analyzed');
		self.analyzedQr = document.getElementById('wm-analyzed-qr');
		
		self.file = document.getElementById('wm-file');
		self.download = document.getElementById('wm-download');
		
		self.canvases = [self.original, self.watermark, self.processed, self.analyzed, self.analyzedQr];
		
		self.clear = function () {
			self.text = '';
			self.lighten = 1;
			
			self.file.value = null;
			
			self.canvases.forEach(function (canvas) {
				canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
			});
		};
		
		self.clear();
		
		self.file.onchange = function (e) {
			$timeout(function () {
				var path = self.file.value.split(/\/|\\/);
				var name = path[path.length - 1];
				name = name.substring(0, name.indexOf('.'));
				self.name = name + 'wm.png';
			});
			
			var reader = new FileReader();
			reader.onload = function (event) {
				var img = new Image();
				img.onload = function () {
					var viewportWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
					var viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
					var canvas = self.original;
					var context = canvas.getContext('2d');
					var width = 0;
					var height = 0;
					if (img.width > img.height) {
						width = viewportWidth * 0.3;
						height = width * img.height / img.width;
					} else {
						height = viewportHeight * 0.35;
						width = height * img.width / img.height;
					}
					self.canvases.forEach(function (c) {
						c.width = img.width;
						c.height = img.height;
						c.style.width = width + 'px';
						c.style.height = height + 'px';
					});
					context.drawImage(img, 0, 0);
					self.update();
				};
				img.src = event.target.result;
			};
			reader.readAsDataURL(e.target.files[0]);
		};
		
		self.imprint = function () {
			// Imprint watermark
			
			var canvas = self.watermark;
			var context = canvas.getContext('2d');
			
			var watermark = context.getImageData(0, 0, canvas.width, canvas.height).data;
			
			var original = self.original;
			
			canvas = self.processed;
			context = canvas.getContext('2d');
			
			context.clearRect(0, 0, canvas.width, canvas.height);
			
			context.drawImage(original, 0, 0);
			
			var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
			var data = imageData.data;
			
			var increment = self.lighten;
			
			for (var i = 0; i < data.length; i += 4) {
				if (!data[i + 3]) {
					data[i] = 255;
					data[i + 1] = 255;
					data[i + 2] = 255;
					data[i + 3] = 255;
				}
				
				var marked = watermark[i + 3] && !watermark[i];
				var pixel = i / 4;
				var x = pixel % canvas.width;
				var y = (pixel - x) / canvas.width;
				var diamond = x % 2 == y % 2;
				if (marked && diamond) {
					var red = data[i];
					var green = data[i + 1];
					var blue = data[i + 2];
					if (red + increment > 255 || green + increment > 255 || blue + increment > 255) {
						data[i] = red - increment;
						data[i + 1] = green - increment;
						data[i + 2] = blue - increment;
					} else {
						data[i] = red + increment;
						data[i + 1] = green + increment;
						data[i + 2] = blue + increment;
					}
				}
			}
			
			context.clearRect(0, 0, canvas.width, canvas.height);
			context.putImageData(imageData, 0, 0);
			
			var contents = canvas.toDataURL('image/png');
			self.download.setAttribute('href', contents);
			
			self.analyze();
		};
		
		self.update = function () {
			if (!self.file.value) {
				return;
			}
			
			var text = self.text;
			
			var canvas = self.watermark;
			var context = canvas.getContext('2d');
			
			if (text != '') {
				
				// Draw watermark
				
				var img = new Image();
				
				img.onload = function () {
					var scale = Math.floor(Math.min(canvas.width, canvas.height) / Math.max(img.width, img.height));
					
					context.clearRect(0, 0, canvas.width, canvas.height);
					
					context.imageSmoothingEnabled = false;
					context.mozImageSmoothingEnabled = false;
					
					context.drawImage(img, 0, 0, img.width * scale, img.height * scale);
					
					self.imprint();
				};
				
				qr.image({
					image: img,
					value: text,
					level: 'H',
					size: 1
				});
				
				// var size = Math.min(canvas.height, canvas.width) / 4;
				
				// function getRandom() {
				// 	return self.randomness / 2 - Math.random() * self.randomness;
				// }
				
				// size *= 1 + getRandom() / 100;
				
				// context.font = 'bold ' + size + 'px sans-serif';
				
				// var measure = context.measureText(text);
				// var width = measure.width;
				
				// var x = canvas.width / 2 - width / 2;
				// var y = canvas.height / 2
				
				// x += getRandom() / 100 * size;
				// y += getRandom() / 100 * size;
				
				// context.fillText(text, x, y);
			} else {
				context.clearRect(0, 0, canvas.width, canvas.height);
				
				self.imprint();
			}
		};
		
		self.analyze = function () {
			var canvas = self.processed;
			var context = canvas.getContext('2d');
			
			var original = context.getImageData(0, 0, canvas.width, canvas.height).data;
			
			canvas = self.analyzed;
			context = canvas.getContext('2d');
			
			context.clearRect(0, 0, canvas.width, canvas.height);
			
			var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
			var data = imageData.data;
			
			function getPixel(x, y) {
				var pixel = y * canvas.width + x;
				if (pixel < 0 || pixel > data.length) {
					return null;
				}
				return pixel;
			}
			
			for (var x = 0; x < canvas.width; x++) {
				for (var y = 0; y < canvas.height; y++) {
					var pixel = getPixel(x, y);
					var i = pixel * 4;
					
					var red = original[i];
					var green = original[i + 1];
					var blue = original[i + 2];
					
					var up = getPixel(x, y - 1);
					var down = getPixel(x, y + 1);
					var left = getPixel(x - 1, y);
					var right = getPixel(x + 1, y);
					
					var surround = [up, down, left, right];
					
					var diffs = surround.map(function (pos) {
						if (pos !== null) {
							var index = pos * 4;
							var redDiff = original[index] - red;
							var greenDiff = original[index + 1] - green;
							var blueDiff = original[index + 2] - blue;
							if (redDiff == greenDiff && greenDiff == blueDiff && Math.abs(redDiff) == 1) {
								return redDiff;
							}
							return null;
						}
						return null;
					});
					
					var reduced = diffs.reduce(function (a, b) {
						return a === b ? a : false;
					});
					
					if (reduced) {
						data[i + 3] = 255;
					}
				}
			}
			
			// Loop again to remove outliers
			
			for (var x = 0; x < canvas.width; x++) {
				for (var y = 0; y < canvas.height; y++) {
					var pixel = getPixel(x, y);
					var i = pixel * 4;
					if (data[i + 3]) {
						var up = getPixel(x, y - 1);
						var down = getPixel(x, y + 1);
						var left = getPixel(x - 1, y);
						var right = getPixel(x + 1, y);
						
						var surround = [up, down, left, right];
						var diffs = surround.map(function (pos) {
							if (pos !== null) {
								var index = pos * 4;
								return data[index + 3];
							}
							return false;
						});
						if (!diffs.reduce(function (a, b) {
							return a || b;
						})) {
							data[i + 3] = 0;
						}
					}
				}
			}
			
			context.putImageData(imageData, 0, 0);
			
			// Attempt to generate qr code
			
			// First, figure out dimension of qr code
			
			var left = [];
			var right = [];
			var top = [];
			var bot = [];
			
			for (var x = 0; x < canvas.width; x++) {
				for (var y = 0; y < canvas.height; y++) {
					var pixel = getPixel(x, y);
					var i = pixel * 4;
					if (data[i + 3]) {
						if (left[y] === undefined) {
							left[y] = x;
						}
						if (top[x] === undefined) {
							top[x] = y;
						}
						right[y] = x;
						bot[x] = y;
					}
				}
			}
			
			var widths = [];
			for (var i = 0; i < left.length; i++) {
				if (right[i] !== undefined && left[i] !== undefined) {
					widths.push(right[i] - left[i]);
				}
			}
			var heights = [];
			for (var i = 0; i < top.length; i++) {
				if (bot[i] !== undefined && top[i] !== undefined) {
					heights.push(bot[i] - top[i]);
				}
			}
			
			function mode(array) {
				var freq = [];
				var highestFreq = 0;
				var num;
				array.forEach(function (val) {
					var f = (freq[val] === undefined ? 0 : freq[val]) + 1;
					freq[val] = f;
					if (f > highestFreq) {
						highestFreq = f;
						num = val;
					}
				});
				return num;
			}
			
			var width = mode(widths);
			var height = mode(heights);
			
			var startLeft = mode(left);
			var startTop = mode(top);
			
			if (width !== undefined && width === height) {
				var dim = width;
				var blockSize = Math.ceil(dim / 21);
				
				var expectedBlacks = blockSize * blockSize;
				
				var qr = [];
				for (var i = 0; i < 21; i++) {
					qr.push([]);
				}
				
				for (var x = 0; x < 21; x++) {
					for (var y = 0; y < 21; y++) {
						qr[x][y] = 0;
					}
				}
				
				for (var x = 0; x < dim; x++) {
					for (var y = 0; y < dim; y++) {
						var pixel = getPixel(x + startLeft, y + startTop);
						var i = pixel * 4;
						if (data[i + 3]) {
							qr[Math.floor(x / blockSize)][Math.floor(y / blockSize)]++;
						}
					}
				}
				
				// Fill in areas that have to be filled in
				
				// Horizontals
				for (var i = 0; i < 7; i++) {
					qr[i][0] = expectedBlacks;
				}
				for (var i = 0; i < 7; i++) {
					qr[i][6] = expectedBlacks;
				}
				for (var i = 14; i < 14 + 7; i++) {
					qr[i][0] = expectedBlacks;
				}
				for (var i = 14; i < 14 + 7; i++) {
					qr[i][6] = expectedBlacks;
				}
				for (var i = 0; i < 7; i++) {
					qr[i][14] = expectedBlacks;
				}
				for (var i = 0; i < 7; i++) {
					qr[i][20] = expectedBlacks;
				}
				// Verticals
				for (var i = 0; i < 7; i++) {
					qr[0][i] = expectedBlacks;
				}
				for (var i = 0; i < 7; i++) {
					qr[6][i] = expectedBlacks;
				}
				for (var i = 14; i < 14 + 7; i++) {
					qr[0][i] = expectedBlacks;
				}
				for (var i = 14; i < 14 + 7; i++) {
					qr[6][i] = expectedBlacks;
				}
				for (var i = 0; i < 7; i++) {
					qr[14][i] = expectedBlacks;
				}
				for (var i = 0; i < 7; i++) {
					qr[20][i] = expectedBlacks;
				}
				// Blocks
				for (var x = 0; x < 3; x++) {
					for (var y = 0; y < 3; y++) {
						qr[x + 2][y + 2] = expectedBlacks;
					}
				}
				for (var x = 0; x < 3; x++) {
					for (var y = 0; y < 3; y++) {
						qr[x + 16][y + 2] = expectedBlacks;
					}
				}
				for (var x = 0; x < 3; x++) {
					for (var y = 0; y < 3; y++) {
						qr[x + 2][y + 16] = expectedBlacks;
					}
				}
				
				canvas = self.analyzedQr;
				context = canvas.getContext('2d');
				
				context.clearRect(0, 0, canvas.width, canvas.height);
				
				imageData = context.getImageData(0, 0, canvas.width, canvas.height);
				data = imageData.data;
				
				for (var x = 0; x < dim; x++) {
					for (var y = 0; y < dim; y++) {
						var pixel = getPixel(x + startLeft, y + startTop);
						var i = pixel * 4;
						if (qr[Math.floor(x / blockSize)][Math.floor(y / blockSize)] > expectedBlacks / 20) {
							data[i + 3] = 255;
						}
					}
				}
				
				context.putImageData(imageData, 0, 0);
				
				var img = new Image();
				img.onload = function () {
					QCodeDecoder().decodeFromImage(img, function (error, res) {
						console.log(error);
						console.log(res);
					});
				};
				img.src = canvas.toDataURL('image/png');
			} else {
				console.log('Unable to determine qr code dimensions: width=' + width + ' height=' + height);
				
				context.putImageData(imageData, 0, 0);
			}
			
		};
	}
]);
</script>
</head>
<body ng-cloak ng-app="WMJS" ng-controller="WMJSCtrl as ctrl">
<md-content class="md-padding" layout="column" layout-align="start center">
<div layout="row" layout-align="center start">
	<div layout="column" layout-align="start center">
		<h1>Watermark Analysis</h1>
		<canvas id="wm-analyzed" ng-hide="false"></canvas>
		<canvas id="wm-analyzed-qr" ng-hide="false"></canvas>
	</div>
	<div layout="column" layout-align="start center">
		<h1>Uploaded Image</h1>
		<canvas id="wm-original"></canvas>
	</div>
	<div layout="column" layout-align="start center">
		<h1>Watermarked Image</h1>
		<canvas id="wm-watermark" ng-hide="false"></canvas>
		<canvas id="wm-processed" ng-hide="false"></canvas>
	</div>
</div>
<div layout="row" layout-align="center start" class="md-padding">
	<div class="md-padding">
		<input id="wm-file" type="file">
	</div>
	<md-input-container>
		<label>Watermark</label>
		<input ng-model="ctrl.text" md-maxlength="7">
	</md-input-container>
	<md-button class="md-raised md-primary" ng-click="ctrl.update()">Generate</md-button>
	<md-input-container>
		<label>Download Name</label>
		<input ng-model="ctrl.name">
	</md-input-container>
	<md-button id="wm-download" class="md-raised md-primary" download="{{ctrl.name}}" ng-href="#">Download Watermarked</md-button>
</div>
</md-content>
</body>
</html>